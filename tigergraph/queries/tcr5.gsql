USE GRAPH ldbc_fin
CREATE OR REPLACE QUERY tcr5(
  VERTEX<Person> id,
  UINT startTime,
  UINT endTime,
  INT truncationLimit,
  STRING truncationOrder = "TIMESTAMP_DESCENDING"
) FOR GRAPH ldbc_fin SYNTAX V1 {
  MapAccum<STRING, MinAccum<UINT>> @map_path_min_timestamp;
  MaxAccum<INT> @max_hop;
  ListAccum<STRING> @@list_path;
  ListAccum<STRING> @@list_path_ordered;
  STRING delimiter = "->";
  Nodes = {id};
  Nodes =
    SELECT t
    FROM   Nodes:s -(own:e)- :t
    POST-ACCUM
           t.@map_path_min_timestamp += (to_string(t.id) -> 0)
  ;
  UINT path_len = 1;
  All_Nodes = {};
  WHILE Nodes.size() > 0 LIMIT 3 DO
    Nodes =
      SELECT t
      FROM   Nodes:s -(transfer:e)- :t
      WHERE  e.timestamp > startTime
             AND e.timestamp < endTime
      ACCUM  FOREACH (str_path, min_timestamp) IN s.@map_path_min_timestamp DO
               IF e.timestamp > min_timestamp
                 AND circle_and_len_check(str_path, to_string(t.id), path_len, delimiter) == TRUE THEN // str_path's length is equal to path_len-1 and no circle
                 t.@map_path_min_timestamp += (str_path + delimiter + to_string(t.id) -> e.timestamp),
                 t.@max_hop += path_len
               END
             END
      HAVING t.@max_hop == path_len
    ;
    All_Nodes = All_Nodes UNION Nodes;
    path_len = path_len + 1;
  END;
  All_Nodes =
    SELECT s
    FROM   All_Nodes:s
    POST-ACCUM
           FOREACH (str_path, min_timestamp) IN s.@map_path_min_timestamp DO
             IF min_timestamp > 0 THEN
               @@list_path += str_path
             END
           END
  ;
  path_len = 3;
  WHILE path_len >= 1 DO
    FOREACH str_path IN @@list_path DO
      IF get_path_len(str_path, delimiter) == path_len THEN
        @@list_path_ordered += str_path;
      END;
    END;
    path_len = path_len - 1;
  END;
  PRINT @@list_path_ordered AS path;
}